import 'dart:convert';
import 'package:flutter/services.dart';
import 'package:cheat_days/features/admin/data/admin_ai_service.dart';
import 'package:cheat_days/features/admin/presentation/recipe_editor_screen.dart';
import 'package:cheat_days/features/admin/presentation/ai_recipe_generator_screen.dart';
import 'package:cheat_days/features/recipes/data/recipe_repository.dart';
import 'package:cheat_days/features/recipes/domain/recipe.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:cheat_days/features/admin/presentation/admin_login_screen.dart';
import 'package:uuid/uuid.dart';

class AdminDashboardScreen extends ConsumerWidget {
  const AdminDashboardScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // We reuse the existing RecipeRepository!
    final recipesAsync = ref.watch(
      recipeListProvider,
    ); // ensure this provider exists or create one

    return Scaffold(
      appBar: AppBar(
        title: const Text("Messie Admin Dashboard"),
        actions: [
          // AI Recipe Generator button
          IconButton(
            icon: const Icon(Icons.auto_awesome),
            tooltip: 'AI ãƒ¬ã‚·ãƒ”ä¸€æ‹¬ç”Ÿæˆ',
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (_) => const AiRecipeGeneratorScreen(),
                ),
              );
            },
          ),
          // Bulk JSON Import button
          IconButton(
            icon: const Icon(Icons.upload_file),
            tooltip: 'Bulk Import JSON',
            onPressed: () => _showBulkImportDialog(context, ref),
          ),
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () async {
              await FirebaseAuth.instance.signOut();
              if (!context.mounted) return;
              Navigator.pushReplacement(
                context,
                MaterialPageRoute(builder: (_) => const AdminLoginScreen()),
              );
            },
          ),
        ],
      ),
      body: recipesAsync.when(
        data: (recipes) => _RecipeDataTable(recipes: recipes),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, s) => Center(child: Text("Error: $e")),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () {
          Navigator.push(
            context,
            MaterialPageRoute(builder: (_) => const RecipeEditorScreen()),
          );
        },
        label: const Text("Add Recipe"),
        icon: const Icon(Icons.add),
      ),
    );
  }

  void _showBulkImportDialog(BuildContext context, WidgetRef ref) {
    final controller = TextEditingController();

    showDialog(
      context: context,
      builder:
          (ctx) => AlertDialog(
            title: const Text('Bulk Import Recipes (JSON)'),
            content: SizedBox(
              width: 600,
              height: 400,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Paste JSON array of recipes generated by AI:',
                    style: TextStyle(fontSize: 12, color: Colors.grey),
                  ),
                  const SizedBox(height: 8),
                  Expanded(
                    child: TextField(
                      controller: controller,
                      maxLines: null,
                      expands: true,
                      decoration: const InputDecoration(
                        border: OutlineInputBorder(),
                        hintText:
                            '[{"name": "Recipe 1", ...}, {"name": "Recipe 2", ...}]',
                      ),
                    ),
                  ),
                ],
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(ctx),
                child: const Text('Cancel'),
              ),
              ElevatedButton(
                onPressed: () async {
                  Navigator.pop(ctx);
                  await _importBulkJson(context, ref, controller.text);
                },
                child: const Text('Import'),
              ),
            ],
          ),
    );
  }

  Future<void> _importBulkJson(
    BuildContext context,
    WidgetRef ref,
    String jsonStr,
  ) async {
    if (jsonStr.trim().isEmpty) return;

    try {
      final dynamic decoded = jsonDecode(jsonStr);
      List<dynamic> recipeList;

      // Support both { "recipes": [...] } and direct array [...]
      if (decoded is List) {
        recipeList = decoded;
      } else if (decoded is Map && decoded['recipes'] != null) {
        recipeList = decoded['recipes'] as List;
      } else {
        throw FormatException(
          'Invalid JSON format. Expected array or {"recipes": [...]}',
        );
      }

      final repo = ref.read(recipeRepositoryProvider);
      int successCount = 0;
      int errorCount = 0;
      final errors = <String>[];

      for (int i = 0; i < recipeList.length; i++) {
        try {
          final data = recipeList[i] as Map<String, dynamic>;
          final recipe = Recipe(
            id: const Uuid().v4(),
            name: data['name'] ?? 'Unnamed Recipe',
            imageUrl: data['imageUrl'] ?? '',
            category: data['category'] ?? 'main',
            cuisine: data['cuisine'] ?? 'japanese',
            timeMinutes: data['timeMinutes'] ?? 30,
            costYen: data['costYen'] ?? 500,
            difficulty: data['difficulty'] ?? 1,
            seasons: List<String>.from(data['seasons'] ?? []),
            calories: data['calories'],
            ingredients:
                (data['ingredients'] as List<dynamic>?)
                    ?.map(
                      (i) => Ingredient(
                        name: i['name'] ?? '',
                        amount: i['amount']?.toString() ?? '',
                        unit: i['unit'] ?? '',
                        isMain: i['isMain'] ?? false,
                      ),
                    )
                    .toList() ??
                [],
            steps: List<String>.from(data['steps'] ?? []),
            tags: List<String>.from(data['tags'] ?? []),
            createdAt: DateTime.now(),
          );

          await repo.saveRecipe(recipe);
          successCount++;
        } catch (e) {
          errorCount++;
          errors.add('Recipe ${i + 1}: $e');
        }
      }

      // Refresh the list
      ref.invalidate(recipeListProvider);

      // Show result
      if (context.mounted) {
        showDialog(
          context: context,
          builder:
              (ctx) => AlertDialog(
                title: Text(
                  errorCount == 0
                      ? 'âœ… Import Complete'
                      : 'âš ï¸ Import Completed with Errors',
                ),
                content: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('Successfully imported: $successCount recipes'),
                    if (errorCount > 0) ...[
                      Text(
                        'Failed: $errorCount recipes',
                        style: const TextStyle(color: Colors.red),
                      ),
                      const SizedBox(height: 8),
                      SizedBox(
                        height: 100,
                        child: SingleChildScrollView(
                          child: Text(
                            errors.join('\n'),
                            style: const TextStyle(fontSize: 12),
                          ),
                        ),
                      ),
                    ],
                  ],
                ),
                actions: [
                  TextButton(
                    onPressed: () => Navigator.pop(ctx),
                    child: const Text('OK'),
                  ),
                ],
              ),
        );
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('JSON Parse Error: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}

final recipeListProvider = FutureProvider<List<Recipe>>((ref) async {
  final repo = ref.read(recipeRepositoryProvider);
  return repo.getAllRecipes();
});

class _RecipeDataTable extends ConsumerStatefulWidget {
  final List<Recipe> recipes;
  const _RecipeDataTable({required this.recipes});

  @override
  ConsumerState<_RecipeDataTable> createState() => _RecipeDataTableState();
}

class _RecipeDataTableState extends ConsumerState<_RecipeDataTable> {
  String _filter = 'all'; // all, has_image, no_image
  final Set<String> _generatingImages = {};

  Future<void> _generateImageForRecipe(Recipe recipe) async {
    if (_generatingImages.contains(recipe.id)) return;

    setState(() => _generatingImages.add(recipe.id));

    try {
      final service = ref.read(adminAiServiceProvider);

      // ç”»åƒç”Ÿæˆ
      final imageBytes = await service.generateRecipeImage(recipe.name);
      if (imageBytes == null) {
        throw Exception('ç”»åƒç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      // ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
      final imageUrl = await service.uploadImage(imageBytes, recipe.name);

      // ãƒ¬ã‚·ãƒ”ã‚’æ›´æ–°
      final updatedRecipe = recipe.copyWith(imageUrl: imageUrl);
      await ref.read(recipeRepositoryProvider).saveRecipe(updatedRecipe);

      // ãƒªã‚¹ãƒˆã‚’æ›´æ–°
      ref.invalidate(recipeListProvider);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('ã€Œ${recipe.name}ã€ã®ç”»åƒã‚’ç”Ÿæˆã—ã¾ã—ãŸ')),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('ã‚¨ãƒ©ãƒ¼: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _generatingImages.remove(recipe.id));
      }
    }
  }

  Future<void> _bulkGenerateImages() async {
    final recipesWithoutImages =
        widget.recipes.where((r) => r.imageUrl.isEmpty).toList();

    if (recipesWithoutImages.isEmpty) return;

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('ä¸€æ‹¬ç”»åƒç”Ÿæˆ'),
        content: Text(
          '${recipesWithoutImages.length}ä»¶ã®ãƒ¬ã‚·ãƒ”ã«ç”»åƒã‚’ç”Ÿæˆã—ã¾ã™ã€‚\n'
          'å‡¦ç†ã«ã¯æ™‚é–“ãŒã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx, false),
            child: const Text('ã‚­ãƒ£ãƒ³ã‚»ãƒ«'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(ctx, true),
            child: const Text('é–‹å§‹'),
          ),
        ],
      ),
    );

    if (confirmed != true) return;

    for (final recipe in recipesWithoutImages) {
      if (!mounted) break;
      await _generateImageForRecipe(recipe);
      // ãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–
      await Future.delayed(const Duration(seconds: 2));
    }

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('ä¸€æ‹¬ç”»åƒç”ŸæˆãŒå®Œäº†ã—ã¾ã—ãŸ')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    List<Recipe> filteredRecipes = widget.recipes;
    if (_filter == 'has_image') {
      filteredRecipes =
          widget.recipes.where((r) => r.imageUrl.isNotEmpty).toList();
    } else if (_filter == 'no_image') {
      filteredRecipes =
          widget.recipes.where((r) => r.imageUrl.isEmpty).toList();
    }

    if (filteredRecipes.isEmpty && widget.recipes.isNotEmpty) {
      // Only show empty state if filter yields nothing but recipes exist
    }

    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Filter Chips
          SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            child: Row(
              children: [
                FilterChip(
                  label: const Text("All"),
                  selected: _filter == 'all',
                  onSelected: (b) => setState(() => _filter = 'all'),
                ),
                const SizedBox(width: 8),
                FilterChip(
                  label: Text(
                    "No Image ğŸ–¼ï¸âŒ (${widget.recipes.where((r) => r.imageUrl.isEmpty).length})",
                  ),
                  selected: _filter == 'no_image',
                  backgroundColor: Colors.red[50],
                  selectedColor: Colors.red[100],
                  onSelected: (b) => setState(() => _filter = 'no_image'),
                ),
                const SizedBox(width: 8),
                FilterChip(
                  label: const Text("Has Image ğŸ–¼ï¸âœ…"),
                  selected: _filter == 'has_image',
                  onSelected: (b) => setState(() => _filter = 'has_image'),
                ),
                const SizedBox(width: 16),
                if (widget.recipes.any((r) => r.imageUrl.isEmpty))
                  ElevatedButton.icon(
                    onPressed: _generatingImages.isNotEmpty
                        ? null
                        : () => _bulkGenerateImages(),
                    icon: _generatingImages.isNotEmpty
                        ? const SizedBox(
                            width: 16,
                            height: 16,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          )
                        : const Icon(Icons.auto_awesome),
                    label: Text(
                      _generatingImages.isNotEmpty
                          ? 'ç”Ÿæˆä¸­... (${_generatingImages.length})'
                          : 'ç”»åƒãªã—å…¨ã¦ç”Ÿæˆ',
                    ),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.deepPurple,
                      foregroundColor: Colors.white,
                    ),
                  ),
              ],
            ),
          ),
          const SizedBox(height: 16),

          if (filteredRecipes.isEmpty)
            const Center(
              child: Padding(
                padding: EdgeInsets.all(32.0),
                child: Text("No recipes match filter"),
              ),
            )
          else
            Card(
              child: SizedBox(
                width: double.infinity,
                child: DataTable(
                  showCheckboxColumn: false,
                  columns: const [
                    DataColumn(label: Text("Image")),
                    DataColumn(label: Text("Name")),
                    DataColumn(label: Text("Category")),
                    DataColumn(label: Text("Action")),
                  ],
                  rows:
                      filteredRecipes.map((recipe) {
                        return DataRow(
                          onSelectChanged: (_) {
                            Navigator.push(
                              context,
                              MaterialPageRoute(
                                builder:
                                    (_) => RecipeEditorScreen(recipe: recipe),
                              ),
                            );
                          },
                          cells: [
                            DataCell(
                              SizedBox(
                                width: 50,
                                height: 50,
                                child:
                                    recipe.imageUrl.isNotEmpty
                                        ? Image.network(
                                          recipe.imageUrl,
                                          fit: BoxFit.cover,
                                          errorBuilder:
                                              (_, __, ___) =>
                                                  const Icon(Icons.error),
                                        )
                                        : Container(
                                          color: Colors.grey[200],
                                          child: const Icon(
                                            Icons.image_not_supported,
                                            size: 20,
                                          ),
                                        ),
                              ),
                            ),
                            DataCell(Text(recipe.name)),
                            DataCell(Text(recipe.category)),
                            DataCell(
                              recipe.imageUrl.isEmpty
                                  ? Row(
                                      mainAxisSize: MainAxisSize.min,
                                      children: [
                                        if (_generatingImages.contains(recipe.id))
                                          const SizedBox(
                                            width: 24,
                                            height: 24,
                                            child: CircularProgressIndicator(
                                              strokeWidth: 2,
                                            ),
                                          )
                                        else
                                          IconButton(
                                            icon: const Icon(
                                              Icons.auto_awesome,
                                              color: Colors.deepPurple,
                                            ),
                                            tooltip: "AIç”»åƒç”Ÿæˆ",
                                            onPressed: () =>
                                                _generateImageForRecipe(recipe),
                                          ),
                                        IconButton(
                                          icon: const Icon(
                                            Icons.copy,
                                            color: Colors.blue,
                                          ),
                                          tooltip: "Copy Generation Prompt",
                                          onPressed: () {
                                            final prompt =
                                                "æ¬¡ã®æ–™ç†ã®ç”»åƒã‚’ã‚¤ãƒ©ã‚¹ãƒˆé¢¨ã«ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚æŒ‡å®šä»¥å¤–ã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¯æã‹ãšã€‚ç¾å‘³ã—ãã†ã«ã€‚\n${recipe.name}";
                                            Clipboard.setData(
                                              ClipboardData(text: prompt),
                                            );
                                            ScaffoldMessenger.of(
                                              context,
                                            ).showSnackBar(
                                              const SnackBar(
                                                content: Text(
                                                  "Prompt copied to clipboard!",
                                                ),
                                              ),
                                            );
                                          },
                                        ),
                                      ],
                                    )
                                  : const SizedBox(),
                            ),
                          ],
                        );
                      }).toList(),
                ),
              ),
            ),
        ],
      ),
    );
  }
}
