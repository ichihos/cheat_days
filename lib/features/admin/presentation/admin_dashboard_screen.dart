import 'dart:convert';
import 'package:cheat_days/features/admin/presentation/recipe_editor_screen.dart';
import 'package:cheat_days/features/recipes/data/recipe_repository.dart';
import 'package:cheat_days/features/recipes/domain/recipe.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:cheat_days/features/admin/presentation/admin_login_screen.dart';
import 'package:uuid/uuid.dart';
import 'package:cheat_days/core/widgets/messie_mascot.dart';

class AdminDashboardScreen extends ConsumerWidget {
  const AdminDashboardScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // We reuse the existing RecipeRepository!
    final recipesAsync = ref.watch(
      recipeListProvider,
    ); // ensure this provider exists or create one

    return Scaffold(
      appBar: AppBar(
        title: const Text("Messie Admin Dashboard"),
        actions: [
          // Bulk JSON Import button
          IconButton(
            icon: const Icon(Icons.upload_file),
            tooltip: 'Bulk Import JSON',
            onPressed: () => _showBulkImportDialog(context, ref),
          ),
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () async {
              await FirebaseAuth.instance.signOut();
              Navigator.pushReplacement(
                context,
                MaterialPageRoute(builder: (_) => const AdminLoginScreen()),
              );
            },
          ),
        ],
      ),
      body: recipesAsync.when(
        data: (recipes) => _RecipeDataTable(recipes: recipes),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, s) => Center(child: Text("Error: $e")),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () {
          Navigator.push(
            context,
            MaterialPageRoute(builder: (_) => const RecipeEditorScreen()),
          );
        },
        label: const Text("Add Recipe"),
        icon: const Icon(Icons.add),
      ),
    );
  }

  void _showBulkImportDialog(BuildContext context, WidgetRef ref) {
    final controller = TextEditingController();

    showDialog(
      context: context,
      builder:
          (ctx) => AlertDialog(
            title: const Text('Bulk Import Recipes (JSON)'),
            content: SizedBox(
              width: 600,
              height: 400,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Paste JSON array of recipes generated by AI:',
                    style: TextStyle(fontSize: 12, color: Colors.grey),
                  ),
                  const SizedBox(height: 8),
                  Expanded(
                    child: TextField(
                      controller: controller,
                      maxLines: null,
                      expands: true,
                      decoration: const InputDecoration(
                        border: OutlineInputBorder(),
                        hintText:
                            '[{"name": "Recipe 1", ...}, {"name": "Recipe 2", ...}]',
                      ),
                    ),
                  ),
                ],
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(ctx),
                child: const Text('Cancel'),
              ),
              ElevatedButton(
                onPressed: () async {
                  Navigator.pop(ctx);
                  await _importBulkJson(context, ref, controller.text);
                },
                child: const Text('Import'),
              ),
            ],
          ),
    );
  }

  Future<void> _importBulkJson(
    BuildContext context,
    WidgetRef ref,
    String jsonStr,
  ) async {
    if (jsonStr.trim().isEmpty) return;

    try {
      final dynamic decoded = jsonDecode(jsonStr);
      List<dynamic> recipeList;

      // Support both { "recipes": [...] } and direct array [...]
      if (decoded is List) {
        recipeList = decoded;
      } else if (decoded is Map && decoded['recipes'] != null) {
        recipeList = decoded['recipes'] as List;
      } else {
        throw FormatException(
          'Invalid JSON format. Expected array or {"recipes": [...]}',
        );
      }

      final repo = ref.read(recipeRepositoryProvider);
      int successCount = 0;
      int errorCount = 0;
      final errors = <String>[];

      for (int i = 0; i < recipeList.length; i++) {
        try {
          final data = recipeList[i] as Map<String, dynamic>;
          final recipe = Recipe(
            id: const Uuid().v4(),
            name: data['name'] ?? 'Unnamed Recipe',
            imageUrl: data['imageUrl'] ?? '',
            category: data['category'] ?? 'main',
            cuisine: data['cuisine'] ?? 'japanese',
            timeMinutes: data['timeMinutes'] ?? 30,
            costYen: data['costYen'] ?? 500,
            difficulty: data['difficulty'] ?? 1,
            seasons: List<String>.from(data['seasons'] ?? []),
            calories: data['calories'],
            ingredients:
                (data['ingredients'] as List<dynamic>?)
                    ?.map(
                      (i) => Ingredient(
                        name: i['name'] ?? '',
                        amount: i['amount']?.toString() ?? '',
                        unit: i['unit'] ?? '',
                        isMain: i['isMain'] ?? false,
                      ),
                    )
                    .toList() ??
                [],
            steps: List<String>.from(data['steps'] ?? []),
            tags: List<String>.from(data['tags'] ?? []),
            createdAt: DateTime.now(),
          );

          await repo.saveRecipe(recipe);
          successCount++;
        } catch (e) {
          errorCount++;
          errors.add('Recipe ${i + 1}: $e');
        }
      }

      // Refresh the list
      ref.invalidate(recipeListProvider);

      // Show result
      if (context.mounted) {
        showDialog(
          context: context,
          builder:
              (ctx) => AlertDialog(
                title: Text(
                  errorCount == 0
                      ? '✅ Import Complete'
                      : '⚠️ Import Completed with Errors',
                ),
                content: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('Successfully imported: $successCount recipes'),
                    if (errorCount > 0) ...[
                      Text(
                        'Failed: $errorCount recipes',
                        style: const TextStyle(color: Colors.red),
                      ),
                      const SizedBox(height: 8),
                      SizedBox(
                        height: 100,
                        child: SingleChildScrollView(
                          child: Text(
                            errors.join('\n'),
                            style: const TextStyle(fontSize: 12),
                          ),
                        ),
                      ),
                    ],
                  ],
                ),
                actions: [
                  TextButton(
                    onPressed: () => Navigator.pop(ctx),
                    child: const Text('OK'),
                  ),
                ],
              ),
        );
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('JSON Parse Error: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}

final recipeListProvider = FutureProvider<List<Recipe>>((ref) async {
  final repo = ref.read(recipeRepositoryProvider);
  return repo.getAllRecipes();
});

class _RecipeDataTable extends StatelessWidget {
  final List<Recipe> recipes;
  const _RecipeDataTable({required this.recipes});

  @override
  Widget build(BuildContext context) {
    if (recipes.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const MessieMascot(size: 200),
            const SizedBox(height: 24),
            Text(
              "No recipes found.\nPaste JSON or Add Manually!",
              textAlign: TextAlign.center,
              style: Theme.of(
                context,
              ).textTheme.titleLarge?.copyWith(color: Colors.grey[600]),
            ),
          ],
        ),
      );
    }

    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Card(
        child: SizedBox(
          width: double.infinity,
          child: DataTable(
            showCheckboxColumn: false,
            columns: const [
              DataColumn(label: Text("Image")),
              DataColumn(label: Text("Name")),
              DataColumn(label: Text("Category")),
              DataColumn(label: Text("Time")),
              DataColumn(label: Text("Cost")),
            ],
            rows:
                recipes.map((recipe) {
                  return DataRow(
                    onSelectChanged: (_) {
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (_) => RecipeEditorScreen(recipe: recipe),
                        ),
                      );
                    },
                    cells: [
                      DataCell(
                        SizedBox(
                          width: 50,
                          height: 50,
                          child: Image.network(
                            recipe.imageUrl,
                            fit: BoxFit.cover,
                            errorBuilder:
                                (_, __, ___) => const Icon(Icons.error),
                          ),
                        ),
                      ),
                      DataCell(Text(recipe.name)),
                      DataCell(Text(recipe.category)),
                      DataCell(Text("${recipe.timeMinutes} min")),
                      DataCell(Text("¥${recipe.costYen}")),
                    ],
                  );
                }).toList(),
          ),
        ),
      ),
    );
  }
}
