import 'dart:convert';
import 'package:flutter/services.dart';
import 'package:cheat_days/features/admin/presentation/recipe_editor_screen.dart';
import 'package:cheat_days/features/recipes/data/recipe_repository.dart';
import 'package:cheat_days/features/recipes/domain/recipe.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:cheat_days/features/admin/presentation/admin_login_screen.dart';
import 'package:uuid/uuid.dart';

class AdminDashboardScreen extends ConsumerWidget {
  const AdminDashboardScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // We reuse the existing RecipeRepository!
    final recipesAsync = ref.watch(
      recipeListProvider,
    ); // ensure this provider exists or create one

    return Scaffold(
      appBar: AppBar(
        title: const Text("Messie Admin Dashboard"),
        actions: [
          // Bulk JSON Import button
          IconButton(
            icon: const Icon(Icons.upload_file),
            tooltip: 'Bulk Import JSON',
            onPressed: () => _showBulkImportDialog(context, ref),
          ),
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () async {
              await FirebaseAuth.instance.signOut();
              Navigator.pushReplacement(
                context,
                MaterialPageRoute(builder: (_) => const AdminLoginScreen()),
              );
            },
          ),
        ],
      ),
      body: recipesAsync.when(
        data: (recipes) => _RecipeDataTable(recipes: recipes),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, s) => Center(child: Text("Error: $e")),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () {
          Navigator.push(
            context,
            MaterialPageRoute(builder: (_) => const RecipeEditorScreen()),
          );
        },
        label: const Text("Add Recipe"),
        icon: const Icon(Icons.add),
      ),
    );
  }

  void _showBulkImportDialog(BuildContext context, WidgetRef ref) {
    final controller = TextEditingController();

    showDialog(
      context: context,
      builder:
          (ctx) => AlertDialog(
            title: const Text('Bulk Import Recipes (JSON)'),
            content: SizedBox(
              width: 600,
              height: 400,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Paste JSON array of recipes generated by AI:',
                    style: TextStyle(fontSize: 12, color: Colors.grey),
                  ),
                  const SizedBox(height: 8),
                  Expanded(
                    child: TextField(
                      controller: controller,
                      maxLines: null,
                      expands: true,
                      decoration: const InputDecoration(
                        border: OutlineInputBorder(),
                        hintText:
                            '[{"name": "Recipe 1", ...}, {"name": "Recipe 2", ...}]',
                      ),
                    ),
                  ),
                ],
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(ctx),
                child: const Text('Cancel'),
              ),
              ElevatedButton(
                onPressed: () async {
                  Navigator.pop(ctx);
                  await _importBulkJson(context, ref, controller.text);
                },
                child: const Text('Import'),
              ),
            ],
          ),
    );
  }

  Future<void> _importBulkJson(
    BuildContext context,
    WidgetRef ref,
    String jsonStr,
  ) async {
    if (jsonStr.trim().isEmpty) return;

    try {
      final dynamic decoded = jsonDecode(jsonStr);
      List<dynamic> recipeList;

      // Support both { "recipes": [...] } and direct array [...]
      if (decoded is List) {
        recipeList = decoded;
      } else if (decoded is Map && decoded['recipes'] != null) {
        recipeList = decoded['recipes'] as List;
      } else {
        throw FormatException(
          'Invalid JSON format. Expected array or {"recipes": [...]}',
        );
      }

      final repo = ref.read(recipeRepositoryProvider);
      int successCount = 0;
      int errorCount = 0;
      final errors = <String>[];

      for (int i = 0; i < recipeList.length; i++) {
        try {
          final data = recipeList[i] as Map<String, dynamic>;
          final recipe = Recipe(
            id: const Uuid().v4(),
            name: data['name'] ?? 'Unnamed Recipe',
            imageUrl: data['imageUrl'] ?? '',
            category: data['category'] ?? 'main',
            cuisine: data['cuisine'] ?? 'japanese',
            timeMinutes: data['timeMinutes'] ?? 30,
            costYen: data['costYen'] ?? 500,
            difficulty: data['difficulty'] ?? 1,
            seasons: List<String>.from(data['seasons'] ?? []),
            calories: data['calories'],
            ingredients:
                (data['ingredients'] as List<dynamic>?)
                    ?.map(
                      (i) => Ingredient(
                        name: i['name'] ?? '',
                        amount: i['amount']?.toString() ?? '',
                        unit: i['unit'] ?? '',
                        isMain: i['isMain'] ?? false,
                      ),
                    )
                    .toList() ??
                [],
            steps: List<String>.from(data['steps'] ?? []),
            tags: List<String>.from(data['tags'] ?? []),
            createdAt: DateTime.now(),
          );

          await repo.saveRecipe(recipe);
          successCount++;
        } catch (e) {
          errorCount++;
          errors.add('Recipe ${i + 1}: $e');
        }
      }

      // Refresh the list
      ref.invalidate(recipeListProvider);

      // Show result
      if (context.mounted) {
        showDialog(
          context: context,
          builder:
              (ctx) => AlertDialog(
                title: Text(
                  errorCount == 0
                      ? '‚úÖ Import Complete'
                      : '‚ö†Ô∏è Import Completed with Errors',
                ),
                content: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('Successfully imported: $successCount recipes'),
                    if (errorCount > 0) ...[
                      Text(
                        'Failed: $errorCount recipes',
                        style: const TextStyle(color: Colors.red),
                      ),
                      const SizedBox(height: 8),
                      SizedBox(
                        height: 100,
                        child: SingleChildScrollView(
                          child: Text(
                            errors.join('\n'),
                            style: const TextStyle(fontSize: 12),
                          ),
                        ),
                      ),
                    ],
                  ],
                ),
                actions: [
                  TextButton(
                    onPressed: () => Navigator.pop(ctx),
                    child: const Text('OK'),
                  ),
                ],
              ),
        );
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('JSON Parse Error: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}

final recipeListProvider = FutureProvider<List<Recipe>>((ref) async {
  final repo = ref.read(recipeRepositoryProvider);
  return repo.getAllRecipes();
});

class _RecipeDataTable extends StatefulWidget {
  final List<Recipe> recipes;
  const _RecipeDataTable({required this.recipes});

  @override
  State<_RecipeDataTable> createState() => _RecipeDataTableState();
}

class _RecipeDataTableState extends State<_RecipeDataTable> {
  String _filter = 'all'; // all, has_image, no_image

  @override
  Widget build(BuildContext context) {
    List<Recipe> filteredRecipes = widget.recipes;
    if (_filter == 'has_image') {
      filteredRecipes =
          widget.recipes.where((r) => r.imageUrl.isNotEmpty).toList();
    } else if (_filter == 'no_image') {
      filteredRecipes =
          widget.recipes.where((r) => r.imageUrl.isEmpty).toList();
    }

    if (filteredRecipes.isEmpty && widget.recipes.isNotEmpty) {
      // Only show empty state if filter yields nothing but recipes exist
    }

    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Filter Chips
          SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            child: Row(
              children: [
                FilterChip(
                  label: const Text("All"),
                  selected: _filter == 'all',
                  onSelected: (b) => setState(() => _filter = 'all'),
                ),
                const SizedBox(width: 8),
                FilterChip(
                  label: const Text("No Image üñºÔ∏è‚ùå"),
                  selected: _filter == 'no_image',
                  backgroundColor: Colors.red[50],
                  selectedColor: Colors.red[100],
                  onSelected: (b) => setState(() => _filter = 'no_image'),
                ),
                const SizedBox(width: 8),
                FilterChip(
                  label: const Text("Has Image üñºÔ∏è‚úÖ"),
                  selected: _filter == 'has_image',
                  onSelected: (b) => setState(() => _filter = 'has_image'),
                ),
              ],
            ),
          ),
          const SizedBox(height: 16),

          if (filteredRecipes.isEmpty)
            const Center(
              child: Padding(
                padding: EdgeInsets.all(32.0),
                child: Text("No recipes match filter"),
              ),
            )
          else
            Card(
              child: SizedBox(
                width: double.infinity,
                child: DataTable(
                  showCheckboxColumn: false,
                  columns: const [
                    DataColumn(label: Text("Image")),
                    DataColumn(label: Text("Name")),
                    DataColumn(label: Text("Category")),
                    DataColumn(label: Text("Action")),
                  ],
                  rows:
                      filteredRecipes.map((recipe) {
                        return DataRow(
                          onSelectChanged: (_) {
                            Navigator.push(
                              context,
                              MaterialPageRoute(
                                builder:
                                    (_) => RecipeEditorScreen(recipe: recipe),
                              ),
                            );
                          },
                          cells: [
                            DataCell(
                              SizedBox(
                                width: 50,
                                height: 50,
                                child:
                                    recipe.imageUrl.isNotEmpty
                                        ? Image.network(
                                          recipe.imageUrl,
                                          fit: BoxFit.cover,
                                          errorBuilder:
                                              (_, __, ___) =>
                                                  const Icon(Icons.error),
                                        )
                                        : Container(
                                          color: Colors.grey[200],
                                          child: const Icon(
                                            Icons.image_not_supported,
                                            size: 20,
                                          ),
                                        ),
                              ),
                            ),
                            DataCell(Text(recipe.name)),
                            DataCell(Text(recipe.category)),
                            DataCell(
                              recipe.imageUrl.isEmpty
                                  ? IconButton(
                                    icon: const Icon(
                                      Icons.copy,
                                      color: Colors.blue,
                                    ),
                                    tooltip: "Copy Generation Prompt",
                                    onPressed: () {
                                      final prompt =
                                          "Ê¨°„ÅÆÊñôÁêÜ„ÅÆÁîªÂÉè„Çí„Ç§„É©„Çπ„ÉàÈ¢®„Å´ÁîüÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÊåáÂÆö‰ª•Â§ñ„ÅÆ„É°„Éã„É•„Éº„ÅØÊèè„Åã„Åö„ÄÇÁæéÂë≥„Åó„Åù„ÅÜ„Å´„ÄÇ\n${recipe.name}";
                                      Clipboard.setData(
                                        ClipboardData(text: prompt),
                                      );
                                      ScaffoldMessenger.of(
                                        context,
                                      ).showSnackBar(
                                        const SnackBar(
                                          content: Text(
                                            "Prompt copied to clipboard!",
                                          ),
                                        ),
                                      );
                                    },
                                  )
                                  : const SizedBox(),
                            ),
                          ],
                        );
                      }).toList(),
                ),
              ),
            ),
        ],
      ),
    );
  }
}
